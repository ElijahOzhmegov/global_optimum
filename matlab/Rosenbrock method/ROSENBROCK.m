% Аюпова Д.Р.
%Задача №5 - стр.175
% Решить задачу: f(x)=1-2*x1-2*x2-4*x1*x2+10*(x1)^2+2*(x2)^2=>min
% методами конфигураций, деформированного многогранника, споряженных
% направлений, Розенброка.
%ОТВЕТ: точное решение (0,25;0,75)T
%=======================================================================%

% Функция РОЗЕНБРОКА
function result = ROSENBROCK (f, x0, eps, alpha, beta, N)
% Алгоритм решения по методу Розенброка
%=====================================================================%
% Шаг №1.
% Задаем начальную точку x0, из которой будет осуществляться итерактивный
% поиск направления убывания функции x0 = [ 0.1; 0.11];
% задаем число eps > 0 для остановки алгоритма eps = 0.0001;
% задаем коэффициент растяжения alpha > 1 => alpha = 3;
% задаем коэффициент сжатия 0 < beta < 1 => beta = -0.5;

% длина x0, т.е. количество элементов (n = 2)
n = length (x0);
% выбираем, в качестве линейных независимых и ортогональных направлений, 
% координатные направления:
d = eye (n);
% зададим начальную длину шага вдоль каждого из направлений поиска delta0 > 0
% delta0_1 = 0.05;
% delta0_2 = 0.05;
delta_0 = 0.05*ones(1,n);
% зададим максимально число неудачных серий шагов по всем направлениям по одной итерации  N = 10;
% количество неудачных серий шагов по всем направлениям на одной итерации
l = 0;
% необходимо положить y = x0
y = zeros (n, n+1);
y(:,1) = x0;
% необходимо положить количество итераций k = 0
k = 0;
% необходимо положить delta_i = delta_i_0 для всех i
delta_i = delta_0;
r = 1; % счетчик
xk = x0; %xk_1 = x0;

% алгоритм состоит из 4 шагов, следовательно применим оператор switch,
% который будет содеражать в себе 4 шага, так проще мне следить за процедурой решения
step = 2; % после ввода всех необходимых данных переходим к шагу №2

% ========================================================================= 
% Шаг №2. Сделать шаг по i -му направлению
% Сделаем 5 шагов, где 5 шаг будет обозначать окончание поиска решения
while step ~= 5
    switch step
        case 2 % ==========================================================
             for i = 1:n
                   if (f(y(:, i) + delta_i(i) * d(:, i)) < f(y(:, i))) 
                       y(:, i+1) = y(:, i) + delta_i(i) * d(:, i);
                       delta_i(i) = alpha*delta_i(i);    
                   else
                       y(:, i+1) = y(:, i);
                       delta_i(i) = beta*delta_i(i); 
                   end
                   
                   step = 3;
             end
             
        case 3 % ==========================================================
        % a) если хотя бы один спуск по направлению на шаге №2 был успешным
            if (f(y(:, n+1)) < f (y(:, 1)))
                y (:, 1) = y (:, n+1);
                step = 2; % переход к шагу№2
            end
            % б) если каждый из n последних шагов был неудачным, то оценить успешность поиска по текущей итерации
            if  (f(y(:, n+1)) == f(y(:, 1)))
                xk =y(:, k+1);
                
                if (f(y(:, n+1)) < f(xk))
                    step = 4; % переход к шагу№4
                end
                % если не было ни одного удачного шага на k-ой итерации, то процесс приостановить
                if (f(y(:, n+1)) == f(xk))
                    step = 5; % завершение поиска
                end
                
            end
            % если число последовательно неудачных серий шагов по всем
            % направлениям на текущей итерации не превышает N, проверить условия окончания
            if (l <= N)
                l = l + 1;
                % проверка условия окончания
                while (r <= n) 
                    if (abs (delta_i (r)) <= eps)
                        r = r + 1;
                    else
                        r = n + 1;
                        y(:,1) = y(:, n+1);
                        step = 2; % переход к шагу №2
                    end
                end
                
                r = 1;
                
                if step ~=2
                    result = xk;
                    disp ('Found approximate solution:')
                    disp (result);
                    % xk
                    step = 5; % заверешние 
                end
            else 
                step = 4; % перейти к шагу №4
            end
       % Шаг №4. Проверка окончания условий
        case 4 % ==========================================================
            l = 0;
            xk_1 = y(:, n+1);
            
            if (norm (xk_1 - xk) <= eps)
                % если выполняется это условие, то поиск решения завершается
                step = 5;
                disp ('Found approximate solution:')
                result = xk_1;
                disp (result);
%                 xk_1
            else
                m = 1;
                lambda = zeros (1, n);
                
                for m = 1:n
                    lambda(m) = (xk_1(m) - xk(m))./d(m);
                end
                
                % Необходимо построить новый набор линейно независимых и
                % взаимно ортоганальных направлений поиска, используя
                % процедуру Грама-Шмидта

                a = zeros(1,n);
                b = zeros(1,n);
                D = zeros(1,n);
                
                if (lambda(m) == 0)
                   a(m) = d(m);
                else
                   a(m) = a(m) + lambda(m)*d(m);
                end
                
                if (m == 1)
                   b (m) = a (m);
                else
                   b(m) = a(m) - a(m-1)*D(m-1)*D(m-1);
                   D(m) = b(m)/(norm(b(m)));
                end
                
                % После нахождения новых направлений, следует положить, что:
                d = D; 
                k = k + 1; 
                delta_i = delta_0;
                y(:,1) = xk_1;
                step = 2;                                                
            end          
    end
end